"""Added resource version table

Revision ID: cb8307a4a511
Revises: 37c15fe1ab58
Create Date: 2025-09-03 20:00:25.058224

"""

from typing import Sequence, Union

import sqlalchemy as sa
import sqlmodel

from alembic import op

# revision identifiers, used by Alembic.
revision: str = "cb8307a4a511"  # pragma: allowlist secret
down_revision: Union[str, None] = "37c15fe1ab58"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table(
        "resource_version",
        sa.Column("id", sa.Uuid(), nullable=False),
        sa.Column("created_at", sa.DateTime(), nullable=False),
        sa.Column("created_by_id", sa.Uuid(), nullable=True),
        sa.Column("text", sqlmodel.sql.sqltypes.AutoString(), nullable=False),
        sa.Column("resource_id", sa.Uuid(), nullable=False),
        sa.ForeignKeyConstraint(["created_by_id"], ["user.id"], ondelete="SET NULL"),
        sa.ForeignKeyConstraint(["resource_id"], ["resource.id"], ondelete="CASCADE"),
        sa.PrimaryKeyConstraint("id"),
    )
    op.create_index(
        op.f("ix_resource_version_resource_id"),
        "resource_version",
        ["resource_id"],
        unique=False,
    )

    # Add the column as nullable first
    op.add_column(
        "textchunk", sa.Column("resource_version_id", sa.Uuid(), nullable=True)
    )

    # Transfer resource relationship to resource_versions instead of chunks
    # Also add entire document content to each version so we don't have to rebuild it
    connection = op.get_bind()

    # Get all resources
    resources = connection.execute(
        sa.text("SELECT id, created_by_id FROM resource")
    ).fetchall()

    for resource in resources:
        resource_id = resource[0]
        created_by_id = resource[1]

        # Get chunks for this resource ordered by order column
        chunks = connection.execute(
            sa.text(
                'SELECT id, text FROM textchunk WHERE resource_id = :resource_id ORDER BY "order"'
            ),
            {"resource_id": resource_id},
        ).fetchall()

        # Combine all chunk text
        resource_content = ""
        for chunk in chunks:
            resource_content += chunk[1]  # chunk text

        # Create new resource version
        resource_version_id = connection.execute(
            sa.text("""
                INSERT INTO resource_version (id, created_at, created_by_id, text, resource_id) 
                VALUES (gen_random_uuid(), NOW(), :created_by_id, :text, :resource_id) 
                RETURNING id
            """),
            {
                "created_by_id": created_by_id,
                "text": resource_content,
                "resource_id": resource_id,
            },
        ).fetchone()[0]

        # Update all chunks to point to the new resource version
        for chunk in chunks:
            chunk_id = chunk[0]
            connection.execute(
                sa.text(
                    "UPDATE textchunk SET resource_version_id = :resource_version_id WHERE id = :chunk_id"
                ),
                {"resource_version_id": resource_version_id, "chunk_id": chunk_id},
            )

    # Now make the column non-nullable since all rows should have values
    op.alter_column("textchunk", "resource_version_id", nullable=False)

    # Create index and constraints
    op.drop_index(op.f("ix_textchunk_resource_id"), table_name="textchunk")
    op.create_index(
        op.f("ix_textchunk_resource_version_id"),
        "textchunk",
        ["resource_version_id"],
        unique=False,
    )
    op.create_foreign_key(
        None,
        "textchunk",
        "resource_version",
        ["resource_version_id"],
        ["id"],
        ondelete="CASCADE",
    )

    # Drop the old foreign key and column
    op.drop_constraint(
        op.f("textchunk_resource_id_fkey"), "textchunk", type_="foreignkey"
    )
    op.drop_column("textchunk", "resource_id")
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column(
        "textchunk",
        sa.Column("resource_id", sa.UUID(), autoincrement=False, nullable=True),
    )

    # Recreate textchunk to resource relationship from resource_version
    connection = op.get_bind()

    # Get all chunks with their resource version info
    chunks = connection.execute(
        sa.text("""
            SELECT tc.id, rv.resource_id 
            FROM textchunk tc 
            JOIN resource_version rv ON tc.resource_version_id = rv.id
        """)
    ).fetchall()

    # Update each chunk to point back to the resource
    for chunk in chunks:
        chunk_id = chunk[0]
        resource_id = chunk[1]
        connection.execute(
            sa.text(
                "UPDATE textchunk SET resource_id = :resource_id WHERE id = :chunk_id"
            ),
            {"resource_id": resource_id, "chunk_id": chunk_id},
        )

    # Make resource_id non-nullable and add constraints
    op.alter_column("textchunk", "resource_id", nullable=False)
    op.drop_constraint(None, "textchunk", type_="foreignkey")
    op.create_foreign_key(
        op.f("textchunk_resource_id_fkey"),
        "textchunk",
        "resource",
        ["resource_id"],
        ["id"],
        ondelete="CASCADE",
    )
    op.drop_index(op.f("ix_textchunk_resource_version_id"), table_name="textchunk")
    op.create_index(
        op.f("ix_textchunk_resource_id"), "textchunk", ["resource_id"], unique=False
    )
    op.drop_column("textchunk", "resource_version_id")
    op.drop_index(
        op.f("ix_resource_version_resource_id"), table_name="resource_version"
    )
    op.drop_table("resource_version")
    # ### end Alembic commands ###
